schema {
  query: Query
  mutation: Mutation
}

directive @enum(subgraph: String, value: String) on ENUM_VALUE

directive @globalOptions(
  subgraph: String
  endpoint: String
  operationHeaders: ObjMap
  queryStringOptions: ObjMap
  queryParams: ObjMap
) on OBJECT

directive @httpOperation(
  subgraph: String
  path: String
  operationSpecificHeaders: ObjMap
  httpMethod: HTTPMethod
  isBinary: Boolean
  requestBaseBody: ObjMap
  queryParamArgMap: ObjMap
  queryStringOptionsByParam: ObjMap
) on FIELD_DEFINITION

type Query @globalOptions(subgraph: "my-openapi", endpoint: "/api/v3") {
  "Multiple status values can be provided with comma separated strings"
  myOpenAPIfindPetsByStatus(status: queryInput_findPetsByStatus_status = available): [Pet]
    @resolver(
      subgraph: "my-openapi"
      operation: "query findPetsByStatus($status: queryInput_findPetsByStatus_status) { findPetsByStatus(status: $status) }"
    )
  "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing."
  myOpenAPIfindPetsByTags("Tags to filter by" tags: [String]): [Pet]
    @resolver(
      subgraph: "my-openapi"
      operation: "query findPetsByTags($tags: [String]) { findPetsByTags(tags: $tags) }"
    )
  "Returns a single pet"
  myOpenAPIgetPetById("ID of pet to return" petId: BigInt!): Pet
    @resolver(
      subgraph: "my-openapi"
      operation: "query getPetById($petId: BigInt!) { getPetById(petId: $petId) }"
    )
  "Returns a map of status codes to quantities"
  myOpenAPIgetInventory: JSON
    @resolver(subgraph: "my-openapi", operation: "query getInventory { getInventory }")
  "For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions."
  myOpenAPIgetOrderById("ID of order that needs to be fetched" orderId: BigInt!): Order
    @resolver(
      subgraph: "my-openapi"
      operation: "query getOrderById($orderId: BigInt!) { getOrderById(orderId: $orderId) }"
    )
  "Logs user into the system"
  myOpenAPIloginUser(
    "The user name for login"
    username: String
    "The password for login in clear text"
    password: String
  ): String
    @resolver(
      subgraph: "my-openapi"
      operation: "query loginUser($username: String, $password: String) { loginUser(username: $username, password: $password) }"
    )
  "Logs out current logged in user session"
  myOpenAPIlogoutUser: JSON
    @resolver(subgraph: "my-openapi", operation: "query logoutUser { logoutUser }")
  "Get user by user name"
  myOpenAPIgetUserByName(
    "The name that needs to be fetched. Use user1 for testing."
    username: String!
  ): User
    @resolver(
      subgraph: "my-openapi"
      operation: "query getUserByName($username: String!) { getUserByName(username: $username) }"
    )
}

"Pet object that needs to be added to the store"
type Pet @source(subgraph: "my-openapi", name: "Pet") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String! @source(subgraph: "my-openapi", name: "name")
  myOpenAPIcategory: Category @source(subgraph: "my-openapi", name: "category")
  myOpenAPIphotoUrls: [String]! @source(subgraph: "my-openapi", name: "photoUrls")
  myOpenAPItags: [Tag] @source(subgraph: "my-openapi", name: "tags")
  myOpenAPIstatus: mutation_updatePet_status @source(subgraph: "my-openapi", name: "status")
}

"The `BigInt` scalar type represents non-fractional signed whole numeric values."
scalar BigInt @source(subgraph: "my-openapi", name: "BigInt")

type Category @source(subgraph: "my-openapi", name: "Category") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String @source(subgraph: "my-openapi", name: "name")
}

type Tag @source(subgraph: "my-openapi", name: "Tag") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String @source(subgraph: "my-openapi", name: "name")
}

"pet status in the store"
enum mutation_updatePet_status @source(subgraph: "my-openapi", name: "mutation_updatePet_status") {
  available @source(subgraph: "my-openapi", name: "available")
  pending @source(subgraph: "my-openapi", name: "pending")
  sold @source(subgraph: "my-openapi", name: "sold")
}

"Status values that need to be considered for filter"
enum queryInput_findPetsByStatus_status
  @source(subgraph: "my-openapi", name: "queryInput_findPetsByStatus_status") {
  available @source(subgraph: "my-openapi", name: "available")
  pending @source(subgraph: "my-openapi", name: "pending")
  sold @source(subgraph: "my-openapi", name: "sold")
}

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON
  @source(subgraph: "my-openapi", name: "JSON")
  @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Order @source(subgraph: "my-openapi", name: "Order") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIpetId: BigInt @source(subgraph: "my-openapi", name: "petId")
  myOpenAPIquantity: Int @source(subgraph: "my-openapi", name: "quantity")
  myOpenAPIshipDate: DateTime @source(subgraph: "my-openapi", name: "shipDate")
  myOpenAPIstatus: mutation_placeOrder_status @source(subgraph: "my-openapi", name: "status")
  myOpenAPIcomplete: Boolean @source(subgraph: "my-openapi", name: "complete")
}

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime @source(subgraph: "my-openapi", name: "DateTime")

"Order Status"
enum mutation_placeOrder_status
  @source(subgraph: "my-openapi", name: "mutation_placeOrder_status") {
  placed @source(subgraph: "my-openapi", name: "placed")
  approved @source(subgraph: "my-openapi", name: "approved")
  delivered @source(subgraph: "my-openapi", name: "delivered")
}

type User @source(subgraph: "my-openapi", name: "User") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIusername: String @source(subgraph: "my-openapi", name: "username")
  myOpenAPIfirstName: String @source(subgraph: "my-openapi", name: "firstName")
  myOpenAPIlastName: String @source(subgraph: "my-openapi", name: "lastName")
  myOpenAPIemail: EmailAddress @source(subgraph: "my-openapi", name: "email")
  myOpenAPIpassword: String @source(subgraph: "my-openapi", name: "password")
  myOpenAPIphone: String @source(subgraph: "my-openapi", name: "phone")
  "User Status"
  myOpenAPIuserStatus: Int @source(subgraph: "my-openapi", name: "userStatus")
}

"A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address."
scalar EmailAddress
  @source(subgraph: "my-openapi", name: "EmailAddress")
  @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

type Mutation {
  "Update an existing pet by Id"
  myOpenAPIupdatePet(input: Pet_Input): Pet
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationupdatePet($input: Pet_Input) { updatePet(input: $input) }"
    )
  "Add a new pet to the store"
  myOpenAPIaddPet(input: Pet_Input): Pet
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationaddPet($input: Pet_Input) { addPet(input: $input) }"
    )
  "Updates a pet in the store with form data"
  myOpenAPIupdatePetWithForm(
    "ID of pet that needs to be updated"
    petId: BigInt!
    "Name of pet that needs to be updated"
    name: String
    "Status of pet that needs to be updated"
    status: String
  ): JSON
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationupdatePetWithForm($petId: BigInt!, $name: String, $status: String) { updatePetWithForm(petId: $petId, name: $name, status: $status) }"
    )
  "Deletes a pet"
  myOpenAPIdeletePet(api_key: String, "Pet id to delete" petId: BigInt!): JSON
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationdeletePet($api_key: String, $petId: BigInt!) { deletePet(api_key: $api_key, petId: $petId) }"
    )
  "uploads an image"
  myOpenAPIuploadFile(
    "ID of pet to update"
    petId: BigInt!
    "Additional Metadata"
    additionalMetadata: String
    input: File
  ): ApiResponse
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationuploadFile($petId: BigInt!, $additionalMetadata: String, $input: File) { uploadFile(petId: $petId, additionalMetadata: $additionalMetadata, input: $input) }"
    )
  "Place a new order in the store"
  myOpenAPIplaceOrder(input: Order_Input): Order
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationplaceOrder($input: Order_Input) { placeOrder(input: $input) }"
    )
  "For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors"
  myOpenAPIdeleteOrder("ID of the order that needs to be deleted" orderId: BigInt!): JSON
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationdeleteOrder($orderId: BigInt!) { deleteOrder(orderId: $orderId) }"
    )
  "This can only be done by the logged in user."
  myOpenAPIcreateUser(input: User_Input): User
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationcreateUser($input: User_Input) { createUser(input: $input) }"
    )
  "Creates list of users with given input array"
  myOpenAPIcreateUsersWithListInput(input: [User_Input]): User
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationcreateUsersWithListInput($input: [User_Input]) { createUsersWithListInput(input: $input) }"
    )
  "This can only be done by the logged in user."
  myOpenAPIupdateUser("name that need to be deleted" username: String!, input: User_Input): JSON
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationupdateUser($username: String!, $input: User_Input) { updateUser(username: $username, input: $input) }"
    )
  "This can only be done by the logged in user."
  myOpenAPIdeleteUser("The name that needs to be deleted" username: String!): JSON
    @resolver(
      subgraph: "my-openapi"
      operation: "mutation mutationdeleteUser($username: String!) { deleteUser(username: $username) }"
    )
}

"Pet object that needs to be added to the store"
input Pet_Input @source(subgraph: "my-openapi", name: "Pet_Input") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String! @source(subgraph: "my-openapi", name: "name")
  myOpenAPIcategory: Category_Input @source(subgraph: "my-openapi", name: "category")
  myOpenAPIphotoUrls: [String]! @source(subgraph: "my-openapi", name: "photoUrls")
  myOpenAPItags: [Tag_Input] @source(subgraph: "my-openapi", name: "tags")
  myOpenAPIstatus: mutation_updatePet_status @source(subgraph: "my-openapi", name: "status")
}

input Category_Input @source(subgraph: "my-openapi", name: "Category_Input") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String @source(subgraph: "my-openapi", name: "name")
}

input Tag_Input @source(subgraph: "my-openapi", name: "Tag_Input") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIname: String @source(subgraph: "my-openapi", name: "name")
}

type ApiResponse @source(subgraph: "my-openapi", name: "ApiResponse") {
  myOpenAPIcode: Int @source(subgraph: "my-openapi", name: "code")
  myOpenAPItype: String @source(subgraph: "my-openapi", name: "type")
  myOpenAPImessage: String @source(subgraph: "my-openapi", name: "message")
}

"The `File` scalar type represents a file upload."
scalar File @source(subgraph: "my-openapi", name: "File")

input Order_Input @source(subgraph: "my-openapi", name: "Order_Input") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIpetId: BigInt @source(subgraph: "my-openapi", name: "petId")
  myOpenAPIquantity: Int @source(subgraph: "my-openapi", name: "quantity")
  myOpenAPIshipDate: DateTime @source(subgraph: "my-openapi", name: "shipDate")
  myOpenAPIstatus: mutation_placeOrder_status @source(subgraph: "my-openapi", name: "status")
  myOpenAPIcomplete: Boolean @source(subgraph: "my-openapi", name: "complete")
}

input User_Input @source(subgraph: "my-openapi", name: "User_Input") {
  myOpenAPIid: BigInt @source(subgraph: "my-openapi", name: "id")
  myOpenAPIusername: String @source(subgraph: "my-openapi", name: "username")
  myOpenAPIfirstName: String @source(subgraph: "my-openapi", name: "firstName")
  myOpenAPIlastName: String @source(subgraph: "my-openapi", name: "lastName")
  myOpenAPIemail: EmailAddress @source(subgraph: "my-openapi", name: "email")
  myOpenAPIpassword: String @source(subgraph: "my-openapi", name: "password")
  myOpenAPIphone: String @source(subgraph: "my-openapi", name: "phone")
  "User Status"
  myOpenAPIuserStatus: Int @source(subgraph: "my-openapi", name: "userStatus")
}

scalar ObjMap @source(subgraph: "my-openapi", name: "ObjMap")

enum HTTPMethod @source(subgraph: "my-openapi", name: "HTTPMethod") {
  GET @source(subgraph: "my-openapi", name: "GET")
  HEAD @source(subgraph: "my-openapi", name: "HEAD")
  POST @source(subgraph: "my-openapi", name: "POST")
  PUT @source(subgraph: "my-openapi", name: "PUT")
  DELETE @source(subgraph: "my-openapi", name: "DELETE")
  CONNECT @source(subgraph: "my-openapi", name: "CONNECT")
  OPTIONS @source(subgraph: "my-openapi", name: "OPTIONS")
  TRACE @source(subgraph: "my-openapi", name: "TRACE")
  PATCH @source(subgraph: "my-openapi", name: "PATCH")
}
